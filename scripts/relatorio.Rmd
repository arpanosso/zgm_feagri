---
title: "Relatório de Análise - FEAGRI"
author: "Alan Rodrigo Panosso"
date: "29/10/2020"
output: 
  rmdformats::readthedown:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---

# 1 Índice de Qualidade do Solo (IQS)

```{r message=FALSE,error=FALSE}
# Caregando os pacotes no R
library(tidyverse)
library(nlme)
library(psych)
library(agricolae)
library(ExpDes.pt)
library(pals)
library(car)
library(multcompView)
library(lsmeans)
library(rcompanion)
library(ggpubr)
library(rstatix)
```


```{r,echo=FALSE}
### função para aplicar em cada painel a barra de erro
errFun <- function(x) {
  data.frame(ymin = mean(x) - sd(x)/sqrt(length(x)), 
             ymax = mean(x) + sd(x)/sqrt(length(x)), 
             y = mean(x))}
```

## 1.1 Validação de dados
### Entrada dos dados
```{r}
dados<-read.table(
  "https://raw.githubusercontent.com/arpanosso/zgm_feagri/main/dados/IQS.txt",
  h=TRUE,sep="\t")
glimpse(dados) # Vislumbre

dados <- dados %>% 
  mutate(
    cobertura = sub('\\_.*','',tratamento),
    PDS = sub('.*\\_','',tratamento)
  )

levels(factor(dados$cobertura))
levels(factor(dados$PDS))
levels(factor(dados$ciclo))
levels(factor(dados$tratamento))
levels(factor(dados$linha_entrelinha))
levels(factor(dados$profundidade))

adicional <- dados %>% 
  filter(tratamento == "sem cobertura_pc")
dados<- dados %>% 
  filter(tratamento != "sem cobertura_pc")
```

## 1.2 Gráficos

```{r}
dados %>% 
  group_by(ciclo,tratamento,profundidade,linha_entrelinha) %>%
  ggplot(aes(x=ciclo, y=iqs,fill=as.factor(profundidade)))+
  stat_summary(fun = mean, geom = "bar",
               position = position_dodge()) + 
  stat_summary(fun.data = errFun, geom = "linerange",
               position = position_dodge(.9)) + 
  facet_wrap(~ tratamento) +
  labs(x="Ciclo", y = "IQS",fill="Profundidade")+
   theme_minimal() +
   scale_fill_manual(values=c('#999999','#E69F00','#FF6347'))
```

## 1.3 Análise de variância

```{r}
# fatores
levels(factor(dados$PDS))
levels(factor(dados$ciclo))

# Chaves de agrupamento
cob<-levels(factor(dados$cobertura))
prof<-levels(factor(dados$profundidade)) 
posição<-levels(factor(dados$linha_entrelinha))

# Laços para várias análises
for(i in 1:length(cob)){
  for(j in 1:length(prof)){
      for(k in 1:length(posição)){
        print("-----------------------------------------")
        print(paste(cob[i],prof[j],posição[k]))
        print("-----------------------------------------")
        
        # Criando dados auxiliar
        da<-dados %>% 
          filter(cobertura==cob[i],
                profundidade==prof[j],
                linha_entrelinha==posição[k])
 
        # Criando os dados com o trat adicional
        add <- adicional %>% 
          filter(profundidade==prof[j],linha_entrelinha==posição[k])
        
        # Juntandos os dois dados para o desdobramento de graus de liberdade
        dd<-rbind(da,add)
        y<-dd$iqs
        trat<-as.factor(paste(dd$PDS,dd$ciclo,sep="_"))
        contrastes<-cbind(
          c(-3,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0),
          c(0,-3,0,0,0,1,0,0,0,1,0,0,0,1,0,0),
          c(0,0,-3,0,0,0,1,0,0,0,1,0,0,0,1,0),
          c(0,0,0,-3,0,0,0,1,0,0,0,1,0,0,0,1),
          c(0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0),
          c(0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0),
          c(0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0),
          c(0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0),
          c(0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0),
          c(0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0),
          c(0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0),
          c(0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0),
          c(0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0),
          c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0),
          c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)
          )
        contrasts(trat) <- contrastes
        modelo.contrastes<-aov(y~trat)
        print("------------------ Fatorial vs Testemunha adicional -------------")
        print(summary(modelo.contrastes, 
        split= list(trat= 
                      list("Add vs. Trat (ciclo_1)"=1,
                           "Add vs. Trat (ciclo_2)"=2,
                           "Add vs. Trat (ciclo_3)"=3,
                           "Add vs. Trat (ciclo_4)"=4,
                           "Fatorial"= 5:15)))
        )
        cat("\n")
        
        print("------------------ Teste de  Mauchly’s para esfericidade -------------")
       dm<-da %>% 
          pivot_wider(names_from = ciclo, values_from = iqs) 
       dm <- dm[-(1:6)]
       
      # Calculando a diferença entre grupos
      grp.diff <- dm %>%
         transmute(
            `t1-t2` = `1` - `2`,
            `t1-t3` = `1` - `3`,
            `t1-t4` = `1` - `4`,
            `t2-t3` = `2` - `3`,
            `t3-t4` = `2` - `4`,
            `t3-t4` = `3` - `4`,
         )
      grp.diff  %>% map(var)
      
      res <- anova_test(data = da, dv = iqs, wid = bloco, within = ciclo)
      print(res$`Mauchly's Test for Sphericity`)

      
      print("------------------ Análise de Parcelas Subdivididas -------------")
       psub2.dbc(da$PDS,da$ciclo,da$bloco,da$iqs,
                    quali=c(TRUE,TRUE), mcomp = "tukey", 
                    fac.names = c("PDS","CICLO"))
       cat("\n")
  }}
}
```

# 2 Produção da cana-de-açúcar
## 2.1 Validação de dados
### Entrada dos dados
```{r}
dados<-read.table(
  "https://raw.githubusercontent.com/arpanosso/zgm_feagri/main/dados/producao.txt",
  h=TRUE,sep="\t")
dados<-dados %>% 
  select(ciclo,tratamento,bloco,produção)
glimpse(dados) # Vislumbre

levels(factor(dados$ciclo))
levels(factor(dados$tratamento))
```

## 2.1 Gráficos

```{r}
dados %>% 
  group_by(ciclo,tratamento) %>%
  ggplot(aes(x=ciclo, y=produção,fill=as.factor(tratamento)))+
  stat_summary(fun = mean, geom = "bar",
               position = position_dodge()) + 
  stat_summary(fun.data = errFun, geom = "linerange",
               position = position_dodge(.9)) + 
  facet_wrap(~ tratamento) +
  labs(x="Ciclo", y = "Produção (t/ha)",fill="Tratamento")+
  theme_minimal()+
  scale_fill_manual(values= pals::brewer.accent(n=13))
```

# 3 Atributos do solo
## 3.1 Validação de dados
### Entrada dos dados
```{r}
dados<-read.table(
  "https://raw.githubusercontent.com/arpanosso/zgm_feagri/main/dados/horizontes.txt",
  h=TRUE,sep="\t")
glimpse(dados) # Vislumbre

levels(factor(dados$ciclo))
levels(factor(dados$tratamento))
dados<-dados %>% 
  mutate(linha_entrelinha = if_else(linha_entrelinha=="el","entrelinha","linha"))
levels(factor(dados$linha_entrelinha))
levels(factor(dados$profundidade))
```

# 4 Biomassa Radicular
## 4.1 Validação de dados
### Entrada dos dados
```{r}
dados<-read.table(
  "https://raw.githubusercontent.com/arpanosso/zgm_feagri/main/dados/biomassaRad.txt",
  h=TRUE,sep="\t")
names(dados)<-c("ciclo","tratamento","linha_entrelinha","profundidade","bloco","biomassa_raizes")
glimpse(dados) # Vislumbre
levels(factor(dados$ciclo))
levels(factor(dados$tratamento))
dados<-dados %>% 
  mutate(linha_entrelinha = if_else(linha_entrelinha=="el","entrelinha",if_else(linha_entrelinha=="l","linha","ca")))
levels(factor(dados$linha_entrelinha))
```

# Abordagem em MRT
```{r}
# modelAR1 = lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#             random = ~1|Student,
#             correlation = corAR1(form = ~ Month | Student),
#             data=Data,
#             method="REML")
# 
# modelcorARMA= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                   random = ~1|Student,
#                   correlation = corARMA(form = ~ 1 | Student, q = 1),
#                   data=Data,
#                   method="REML")
# 
# modelcorCompSymm= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                random = ~1|Student,
#                correlation = corCompSymm(form = ~ Month | Student),
#                data=Data,
#                method="REML")
# 
# modelcorCAR1= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                       random = ~1|Student,
#                       correlation = corCAR1(form = ~ Month | Student),
#                       data=Data,
#                       method="REML")
# 
# modelcorExp= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                   random = ~1|Student,
#                   correlation = corExp(form = ~ Month | Student),
#                   data=Data,
#                   method="REML")
# 
# modelcorGaus= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                  random = ~1|Student,
#                  correlation = corGaus(form = ~ Month | Student),
#                  data=Data,
#                  method="REML")
# 
# modelcorLin= lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                   random = ~1|Student,
#                   correlation = corLin(form = ~ Month | Student),
#                   data=Data,
#                   method="REML")
# 
# modelccorRatio=lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                  random = ~1|Student,
#                  correlation = corRatio(form = ~ Month | Student),
#                  data=Data,
#                  method="REML")
# 
# modelcorSpher=lme(Calories.per.day ~ Instruction + Month + Instruction*Month,
#                    random = ~1|Student,
#                    correlation = corSpher(form = ~ Month | Student),
#                    data=Data,
#                    method="REML")
# 
# anova(modelAR1,
#       modelcorCompSymm,
#       modelcorCAR1,
#       modelcorARMA,
#       modelcorExp,
#       modelcorGaus,
#       modelcorLin,
#       modelccorRatio,
#       modelcorSpher)
# 

#       
#       print("------------------ Análise de Medidas Repetidas -------------")
#       model.a = gls(iqs ~ ciclo + as.factor(PDS) + as.factor(PDS)*ciclo,
#              data=da)
#       ACF(model.a,form = ~ ciclo | bloco)
# 
#       model.b = lme(iqs ~ ciclo + as.factor(PDS) + as.factor(PDS)*ciclo,
#                       random = ~1|bloco,
#                       data=da)
#       ACF(model.b,form = ~ ciclo | bloco)
#       cat("\n")
# 
#       modelo.mrt <- lme(iqs ~ ciclo + PDS + ciclo*PDS,
#                             random = ~1|bloco,
#                             data=da,
#                             method = "REML"
#                             )
#       correlation = corAR1(form  = ~ time | subjvar)
#       print(Anova(modelo.mrt))
```

